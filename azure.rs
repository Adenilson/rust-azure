/* automatically generated by rust-bindgen */

import libc::*;
import libc::types::common::c99::*;

type Float = c_float;

type enum_SurfaceType = c_uint;
const SURFACE_DATA: u32 = 0_u32;
const SURFACE_D2D1_BITMAP: u32 = 1_u32;
const SURFACE_D2D1_DRAWTARGET: u32 = 2_u32;
const SURFACE_CAIRO: u32 = 3_u32;
const SURFACE_CAIRO_IMAGE: u32 = 4_u32;
const SURFACE_COREGRAPHICS_IMAGE: u32 = 5_u32;
const SURFACE_COREGRAPHICS_CGCONTEXT: u32 = 6_u32;
const SURFACE_SKIA: u32 = 7_u32;
const SURFACE_DUAL_DT: u32 = 8_u32;

type enum_SurfaceFormat = c_uint;
const FORMAT_B8G8R8A8: u32 = 0_u32;
const FORMAT_B8G8R8X8: u32 = 1_u32;
const FORMAT_R5G6B5: u32 = 2_u32;
const FORMAT_A8: u32 = 3_u32;

type enum_BackendType = c_uint;
const BACKEND_NONE: u32 = 0_u32;
const BACKEND_DIRECT2D: u32 = 1_u32;
const BACKEND_COREGRAPHICS: u32 = 2_u32;
const BACKEND_CAIRO: u32 = 3_u32;
const BACKEND_SKIA: u32 = 4_u32;

type enum_FontType = c_uint;
const FONT_DWRITE: u32 = 0_u32;
const FONT_GDI: u32 = 1_u32;
const FONT_MAC: u32 = 2_u32;
const FONT_SKIA: u32 = 3_u32;
const FONT_CAIRO: u32 = 4_u32;
const FONT_COREGRAPHICS: u32 = 5_u32;

type enum_NativeSurfaceType = c_uint;
const NATIVE_SURFACE_D3D10_TEXTURE: u32 = 0_u32;
const NATIVE_SURFACE_CAIRO_SURFACE: u32 = 1_u32;
const NATIVE_SURFACE_CGCONTEXT: u32 = 2_u32;

type enum_NativeFontType = c_uint;
const NATIVE_FONT_DWRITE_FONT_FACE: u32 = 0_u32;
const NATIVE_FONT_GDI_FONT_FACE: u32 = 1_u32;
const NATIVE_FONT_MAC_FONT_FACE: u32 = 2_u32;
const NATIVE_FONT_SKIA_FONT_FACE: u32 = 3_u32;
const NATIVE_FONT_CAIRO_FONT_FACE: u32 = 4_u32;

type enum_CompositionOp = c_uint;
const OP_OVER: u32 = 0_u32;
const OP_ADD: u32 = 1_u32;
const OP_ATOP: u32 = 2_u32;
const OP_OUT: u32 = 3_u32;
const OP_IN: u32 = 4_u32;
const OP_SOURCE: u32 = 5_u32;
const OP_DEST_IN: u32 = 6_u32;
const OP_DEST_OUT: u32 = 7_u32;
const OP_DEST_OVER: u32 = 8_u32;
const OP_DEST_ATOP: u32 = 9_u32;
const OP_XOR: u32 = 10_u32;
const OP_COUNT: u32 = 11_u32;

type enum_ExtendMode = c_uint;
const EXTEND_CLAMP: u32 = 0_u32;
const EXTEND_REPEAT: u32 = 1_u32;
const EXTEND_REFLECT: u32 = 2_u32;

type enum_FillRule = c_uint;
const FILL_WINDING: u32 = 0_u32;
const FILL_EVEN_ODD: u32 = 1_u32;

type enum_AntialiasMode = c_uint;
const AA_NONE: u32 = 0_u32;
const AA_GRAY: u32 = 1_u32;
const AA_SUBPIXEL: u32 = 2_u32;

type enum_Snapping = c_uint;
const SNAP_NONE: u32 = 0_u32;
const SNAP_ALIGNED: u32 = 1_u32;

type enum_Filter = c_uint;
const FILTER_LINEAR: u32 = 0_u32;
const FILTER_POINT: u32 = 1_u32;

type enum_PatternType = c_uint;
const PATTERN_COLOR: u32 = 0_u32;
const PATTERN_SURFACE: u32 = 1_u32;
const PATTERN_LINEAR_GRADIENT: u32 = 2_u32;
const PATTERN_RADIAL_GRADIENT: u32 = 3_u32;

type enum_JoinStyle = c_uint;
const JOIN_BEVEL: u32 = 0_u32;
const JOIN_ROUND: u32 = 1_u32;
const JOIN_MITER: u32 = 2_u32;
const JOIN_MITER_OR_BEVEL: u32 = 3_u32;

type enum_CapStyle = c_uint;
const CAP_BUTT: u32 = 0_u32;
const CAP_ROUND: u32 = 1_u32;
const CAP_SQUARE: u32 = 2_u32;

type enum_SamplingBounds = c_uint;
const SAMPLING_UNBOUNDED: u32 = 0_u32;
const SAMPLING_BOUNDED: u32 = 1_u32;

type enum_Side = c_uint;
const eSideTop: u32 = 0_u32;
const eSideRight: u32 = 1_u32;
const eSideBottom: u32 = 2_u32;
const eSideLeft: u32 = 3_u32;

type struct__Color = {
    r: Float,
    g: Float,
    b: Float,
    a: Float,
};

type Color = struct__Color;

type struct__GradientStop = {
    offset: Float,
    color: Color,
};

type GradientStop = struct__GradientStop;

type struct__IntRect = {
    x: int32_t,
    y: int32_t,
    width: int32_t,
    height: int32_t,
};

type IntRect = struct__IntRect;

type struct__Rect = {
    x: Float,
    y: Float,
    width: Float,
    height: Float,
};

type Rect = struct__Rect;

type DrawTargetRef = *c_void;

type PatternRef = *c_void;

type ColorPatternRef = *c_void;

#[link_name="azure"]
native mod bindgen {

fn AzureCSanityCheck(/* FIXME: variadic arguments */);

fn CreateDrawTargetForCairoSurface(++arg0: *cairo_surface_t) -> DrawTargetRef;

fn ReleaseDrawTarget(++arg0: DrawTargetRef);

fn CreateColorPattern(++arg0: *Color) -> ColorPatternRef;

fn ReleaseColorPattern(++arg0: ColorPatternRef);

fn DrawTargetFillRect(++arg0: DrawTargetRef, ++arg1: *Rect, ++arg2: PatternRef);

}
